"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[2589],{19543:(e,n,t)=>{t.d(n,{LW:()=>w,vK:()=>v,$y:()=>y,R0:()=>k});var a=t(33403),s=t(90107),o=t(94175);const r="npm:@polkagate/snap",c="0.1.5",i=window.ethereum,u={[r]:{version:`>=${c}`}},l=async e=>(console.log("args in invokeSnap:",e),await window.ethereum.request({method:"wallet_invokeSnap",params:{snapId:e?.snapId||r,request:{method:e.method,params:e?.params}}})),d=(()=>{let e=[];return{subscribe:n=>(e.push(n),()=>{e=e.filter((e=>e!==n))}),notifySubscribers:n=>{e.forEach((e=>e(n)))}}})(),m={connect:async e=>{console.log(`Snap is connecting to ${e} ...`);const n=await(async()=>await window.ethereum.request({method:"wallet_requestSnaps",params:u}))();return console.log("Snap connected, response:",n),{...p,version:n?.[r]?.version}},version:c},p={accounts:{get:async e=>[{address:await l({method:"getAddress",params:{anyType:e}}),name:"Metamask account 1 ðŸ»",type:"sr25519"}],subscribe:d.subscribe},name:"polkamask",signer:{signPayload:async e=>await l({method:"signJSON",params:{payload:e}}),signRaw:async e=>await l({method:"signRaw",params:{raw:e}})},version:c},h=window;h.injectedWeb3=h.injectedWeb3||{};let w=f(),b=null;function f(){return 0!==Object.values(h.injectedWeb3).filter((({connect:e,enable:n})=>!(!e&&!n))).length}function g(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function y(e,n=[]){if(!e)throw new Error("You must pass a name for your app to the web3Enable function");const t=n.length?Promise.all(n.map((e=>e().catch((()=>!1))))):Promise.resolve([!0]);var s;return s=()=>t.then((()=>function(e){return i&&(h.injectedWeb3.metamasksnap=m,console.log("win.injectedWeb3 after adding metamask snap:",h.injectedWeb3)),Promise.all(Object.entries(h.injectedWeb3).map((([n,{connect:t,enable:s,version:o}])=>Promise.resolve().then((()=>t?t(e):s?s(e).then((e=>(0,a.Z)({name:n,version:o||"unknown"},e))):Promise.reject(new Error("No connect(..) or enable(...) hook found")))).catch((({message:e})=>{console.error(`Error initializing ${n}: ${e}`)}))))).then((e=>e.filter((e=>!!e))))}(e).then((e=>e.map((e=>(e.accounts.subscribe||(e.accounts.subscribe=n=>(e.accounts.get().then(n).catch(console.error),()=>{})),e))))).catch((()=>[])).then((e=>{const n=e.map((({name:e,version:n})=>`${e}/${n}`));return w=f(),console.info(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${n.join(", ")}`),e})))),b=new Promise((e=>{"complete"===document.readyState?e(s()):window.addEventListener("load",(()=>e(s())))})),b}async function v({accountType:e,extensions:n,genesisHash:t,ss58Format:a}={}){const r=[],c=await async function(e,n){return b?(await b).filter((({name:e})=>!n||n.includes(e))):g(e)}("web3Accounts",n),i=await Promise.all(c.map((async({accounts:n,name:r})=>{try{return function(e,n,t){return n.map((({address:n,genesisHash:a,name:r,type:c})=>({address:42===n.length?n:(0,s.m)((0,o.m)(n),t),meta:{genesisHash:a,name:r,source:e},type:c})))}(r,function(e,n,t){return e.filter((e=>(!e.type||!t||t.includes(e.type))&&(!e.genesisHash||!n||e.genesisHash===n)))}(await n.get(),t,e),a)}catch{return[]}})));return i.forEach((e=>{r.push(...e)})),console.info(`web3Accounts: Found ${r.length} address${1!==r.length?"es":""}`),r}async function k(e){if(!b)return g("web3FromSource");const n=await b,t=e&&n.find((({name:n})=>n===e));if(!t)throw new Error(`web3FromSource: Unable to find an injected ${e}`);return t}}}]);